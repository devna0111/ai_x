3장 데이터 구조 
	여러가지 자료를 한 변수에 담는 것이 목적
		*** 단일 자료형과 여러 데이터 구조형들은 다르게 변수로 할당하면 같은 주소를 할당받게 되며 수정 시 같이 변동한다!
			따라서 원본 데이터가 중요하고 필요하다면 .copy()를 통해 데이터를 복제하여 사용하자!

	1절 리스트 : [타입과 관련 없는 0개 이상의 데이터들]
		리스트는 슬라이싱, 인덱싱 지원.
		1.1 리스트 생성
		- 리스트는 list(), [ ] 를 통해 만들 수 있다.
		- list() 를 통해 만드려면 요소의 객체가 **순회가능한 객체** 여야 한다.

		1.2 기본 정보 조회
		- min(), max()
		- len()
		- data.sort() : 정렬, 원본이 변경되므로 주의 :: 속도는 sorted()보다 빠르다고 하니 속도가 중요하면 복사뜨고 sort 돌리는게...
		

		1.3 요소 추가
		- +로 리스트 연결 : 새로운 리스트 객체를 생성해서 반환하므로 시간이 조금 더 필요함
		- * 로 리스트 반복 연결
		- append() 요소 한 개 추가
		- extend() 인자 속 리스트 객체를 이어 붙임(연결과 동일하나 원본에 바로 더해 시간 속도 양호, += 기능)
		- insert(idx, val) idx 자리에 val값 추가하고 기존 idx부터 끝까지 인덱스 shift
		
		1.4 인덱싱과 요소 개수
		- 리스트객체[인덱스] : 인덱스를 이용한 접근 : IndexError 주의
		- 리스트객체.index(찾을데이터) : 찾을 데이터가 리스트 객체에 있다면 index 반환. 없으면 IndexError
		- 리스트객체.count(찾을데이터) : 찾을 데이터가 리스트 객체에 몇 개 있는 지 반환 ** 없으면 0!!
		- 리스트객체.index(찾을데이터, position= K) : K 번째 이후에 나오는 찾을 데이터의 인덱스 반환

		1.5 원하는 요소 추출
		- 리스트 슬라이싱 : 문자열과 동일
		- 리스트 컴프리헨션 : 리스트에서 원하는 데이터를 추출

		1.6 요소 수정하기
		- 슬라이싱을 이용해서 요소 수정(step 부분이 미포함 : 부분 리스트가 통째로 수정)
		- step이 포함되면 요소 개수를 맞춰줘야 가능하다! ** 항상 실수 많은 부분

		1.7 요소 삭제하기
		- pop() : 가장 마지막 인덱스 요소가 반환되고 리스트에서 삭제
		- pop(index) : index의 요소가 반환되고 리스트에서 삭제 // 인덱스가 리스트 내에서 모두 수정되며 정말 많은 시공간이 소요
		- remove(value) : 리스트 속에서 value를 찾아서 제일 앞의 요소를 삭제
		- del 변수[idx] : idx번째 요소가 삭제

		1.8 리스트 복사하기
		- sort(), reverseI(), remove()는 원본 데이터를 바꿔버리기에 속도는 빠르지만 원본의 보존이 필요할 때 사용이 불가
		- 새로 담을 변수명 = 원래 리스트.copy() 
		- 위 함수로 사용하면 편리

	2절 튜플 : () 형태, 리스트와 아주 유사하지만 변경이 불가능한 요소. 추가,제거, 변경이 불가능하며 이외 iter 객체로서 필요한 함수는 모두 사용이 가능하다.
		 하나의 인자만 포함시키면 반드시 ,을 포함시켜야 튜플 객체로 인식한다. ex) a = (1,) ** 반점을 찍지 않으면 int, str로 인식(다중할당과 동일)

	3절 딕셔너리 : 중괄호 속에 키와 밸류를 쌍으로 활용.
		이 때 키는 유일한 값만 사용이 가능하여 변경이 가능한 수는 사용할 수 없다.
		값은 어떤 형태이든 중복 값이든 뭐든 지 사용이 가능하다
		인덱스를 이용한 참조는 불가능하다.
		- key 접근 : dict_type.keys()로 가능하나 생략이 가능하다.
		- values 접근 : dict_type.values()로 가능
		- key, value 동시 접근 : dict_type.items()로 가능
		*** 물론 딕셔너리는 순번(idx)을 포함하지 않지만 enumerate()의 경우 순회 가능한 모든 객체에 적용이 가능하며 이 때 가상이 인덱스를 부여받는다.
		pop(키), remove(키), del 딕셔너리[키] 사용이 가능하다.

	4절 집합 : 중복하지 않은 인자를 포함하는 자료구조. 순서가 없어 index가 없으며 딕셔너리와 마찬가지로 enumerate() 함수를 사용해 가상의 인덱스를 부여
		A = {1,2,3,} 의 구조를 갖으며 흔히 아는 집합의 연산이 가능하다. & 교집합 | 합집합 - 차집합
		집합형 자료는 add, update를 사용하여 추가하며 add(단일인자) // update([하나씩 추가할 요소들의 집단자료형]) 상황을 고려하여 사용한다.
		인자의 제거는 remove()를 활용한다.

	5절 enumerate() : 반복자 또는 순환 객체에 대해 idx를 부여하며 반복문을 처리할 때 사용


		